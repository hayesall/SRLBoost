package edu.wisc.cs.will.ILP;

import edu.wisc.cs.will.DataSetUtils.Example;
import edu.wisc.cs.will.FOPC.*;
import edu.wisc.cs.will.Utils.MessageType;
import edu.wisc.cs.will.Utils.Utils;
import edu.wisc.cs.will.Utils.condor.CondorFileOutputStream;
import edu.wisc.cs.will.stdAIsearch.SearchInterrupted;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;

// TODO(@hayesall): The `createThresholds` method needs desperate attention.

/*
 * Note: ALL proofs are found of literals being thresholded, and this could produce a huge list.
 * 
 * @author shavlik
 *
 */
class ThresholdManager {
	
	private final LearnOneClause    innerLoopForILP; // Really only need this one, but get the others for convenience.
	private final HandleFOPCstrings stringHandler;
	private final InlineManager     inlineManager;
	
	private int lowerCounter = 0; // Need unique variables for each use.
	private int upperCounter = 0; // These three probably follow in lock-step, but down the road we might want them to do different things, so keep three counters.
	private int varCounter   = 0; 
	private int valueCounter = 0;

	ThresholdManager(LearnOneClause innerLoopForILP, HandleFOPCstrings stringHandler, InlineManager inlineManager) {
		this.innerLoopForILP = innerLoopForILP;
		this.stringHandler   = stringHandler;
		this.inlineManager   = inlineManager;
	}
	
	void processThresholdRequests(String fileName, Collection<LiteralToThreshold> literalsToThreshold) throws SearchInterrupted {
		try {
			CondorFileOutputStream outStream = (fileName == null ? null : new CondorFileOutputStream(fileName));

			PrintStream          printStream = (fileName == null ? null : new PrintStream(outStream, false)); // (Don't) Request auto-flush (can slow down code).

			if (printStream != null) printStream.println("%%%%%%%%%%%  DO NOT EDIT THIS FILE.  IT'LL BE RE-LOADED AS IS.  %%%%%%%%%%%");

			if (literalsToThreshold != null) for(LiteralToThreshold literal : literalsToThreshold) {
				createThresholds(printStream, stringHandler, literal);
			}
		}
		catch (FileNotFoundException e) {
			Utils.reportStackTrace(e);
			Utils.error("Unable to successfully open this file for writing: " + fileName + ".  Error message: " + e.getMessage());
		}
	}

	// Given the list of values for this numeric argument (in position 'position,' counting from 1), create some literals specifying thresholds.
	// TODO: If TWO lists of values are provided, then thresholds will only be created between 'adjacent' values from
	//       different lists (as is done in decision-tree induction).  E.g., if one list is {1, 3, 5} and the other is {4, 6, 8, 10} then thresholds of interest are  3.5, 4.5, and 5.5.
	private void createThresholds(PrintStream printStream, HandleFOPCstrings stringHandler, LiteralToThreshold literalToThreshold) throws SearchInterrupted {

		// TODO(@hayesall): The only caller for `createThresholds` method was in this class, and class1values / class2values were always null.
		List<Double> class1values;
		List<Double> class2values;

		int     maxCuts             = literalToThreshold.maxCuts;
		boolean createTiles         = literalToThreshold.createTiles;
		boolean firstArgIsExampleID = literalToThreshold.firstArgIsExampleID;
		
		if (literalToThreshold.numberArgs() < 1) { return; }
		
		// No thresholds have been provided, so need to collect them.
		Set<Term> posExIDs = null;
		Set<Term> negExIDs = null;

		class1values = new ArrayList<>(8);
		class2values = new ArrayList<>(8);
		if (firstArgIsExampleID) {
			List<Example> posExamples = innerLoopForILP.getPosExamples();
			List<Example> negExamples = innerLoopForILP.getNegExamples();

			posExIDs = new HashSet<>(4);
			negExIDs = new HashSet<>(4);
			for (Example pos : posExamples) { posExIDs.add(pos.getArgument(0)); }
			for (Example neg : negExamples) { negExIDs.add(neg.getArgument(0)); }
		}

		List<Term> argList = new ArrayList<>(literalToThreshold.numberArgs());
		for (int i = 0; i < literalToThreshold.numberArgs(); i++) {
			argList.add(stringHandler.getNewUnamedVariable());
		}

		Literal    query         = stringHandler.getLiteral(literalToThreshold.predicateName, argList);
		Utils.println(MessageType.ILP_THESHOLDING_VERBOSE, "%   query = " + query);

		List<Term> groundings    = innerLoopForILP.getProver().getAllUniqueGroundings(query); // Note: this can be very cpu intensive!
		Utils.println(MessageType.ILP_THESHOLDING_VERBOSE, "%   |groundings| = " + Utils.getSizeSafely(groundings));
		if (groundings == null) { return; }

		for (Term factAsTerm : groundings) {
			Literal fact = factAsTerm.asLiteral();
			int numbArgs = fact.numberArgs();
			int wArg     = stringHandler.getArgumentPosition(0, numbArgs);
			int sArg     = stringHandler.getArgumentPosition(-1, numbArgs);
			Term argToThreshold = fact.getArgument(literalToThreshold.positionToThreshold - 1);  // Remember that counting starts from 1.
			Term firstArg       = (firstArgIsExampleID ? fact.getArgument(0) : null);

			// firstArgIsExampleID overrides innerLoopForILP.whenComputingThresholdsWorldAndStateArgsMustBeWorldAndStateOfAcurrentExample
			if (!firstArgIsExampleID && innerLoopForILP.whenComputingThresholdsWorldAndStateArgsMustBeWorldAndStateOfAcurrentExample) {
				if (wArg >= 0 && wArg < numbArgs && sArg >= 0 && sArg < numbArgs) {
					if (!innerLoopForILP.isWorldStateArgPairInAnExample(fact.getArgument(wArg), fact.getArgument(sArg))) {
						continue;
					}
				}
			}

			if (argToThreshold instanceof NumericConstant) {
				double valueInFact = ((NumericConstant) argToThreshold).value.doubleValue();{ Utils.println(MessageType.ILP_THESHOLDING_VERBOSE, "%   found: " + valueInFact + " in '" + fact + "'"); }
				boolean inPos = (firstArgIsExampleID && posExIDs.contains(firstArg)) || (!firstArgIsExampleID && innerLoopForILP.whenComputingThresholdsWorldAndStateArgsMustBeWorldAndStateOfAcurrentExample && innerLoopForILP.isWorldStateArgPairInAnPosExample(fact.getArgument(wArg), fact.getArgument(sArg)));
				boolean inNeg = (firstArgIsExampleID && negExIDs.contains(firstArg)) || (!firstArgIsExampleID && innerLoopForILP.whenComputingThresholdsWorldAndStateArgsMustBeWorldAndStateOfAcurrentExample && innerLoopForILP.isWorldStateArgPairInAnNegExample(fact.getArgument(wArg), fact.getArgument(sArg)));
				// If this is true and firstArgIsExampleID is as well, then ignore values that do not connect to neither a positive nor a negative example.
				if (inPos && inNeg) {
					class1values.add(valueInFact); // If ambiguous, play it safe.
					class2values.add(valueInFact);
				} else if (inPos) {
					class1values.add(valueInFact);
				} else if (inNeg) {
					class2values.add(valueInFact);
				} else {
					class1values.add(valueInFact);
				}
			}
			else {
				Utils.warning("% Was expecting a number in argument #" + literalToThreshold.positionToThreshold + " but got: '" + argToThreshold + "' in '" + fact + "'.  Will ignore this fact.");
			}
		}

		List<Double> orgList1 = new ArrayList<>(class1values.size());
		List<Double> orgList2 = new ArrayList<>(class2values.size());
		orgList1.addAll(class1values);
		orgList2.addAll(class2values);

		Utils.sortListOfDoublesAndRemoveDuplicates(class1values);
		Utils.sortListOfDoublesAndRemoveDuplicates(class2values);

		// In the next group, we reduce the TWO sets of values into ONE.
		int numbClass1values = Utils.getSizeSafely(class1values);
		int numbClass2values = Utils.getSizeSafely(class2values);
		if (numbClass1values < 1 && numbClass2values > 0) { // In only have class2 values, assign all values to class1.
			class1values = class2values;
			class2values = null;			
		} else if (numbClass1values > 0 && numbClass2values > 0) { // If we have both class1 and class2 values, need to collect the boundaries.
			List<Double> valuesToKeep = new ArrayList<>(8);
			Double old1 = null;
			Double old2 = null;
			int counter1 = 0;
			int counter2 = 0;
			double frontOf1 = class1values.get(counter1);
			double frontOf2 = class2values.get(counter2);
			int    focus    = (frontOf1 < frontOf2 ? 1 : 2); // Keep track of which list has the smaller number.
			
			while (counter1 < numbClass1values && counter2 < numbClass2values) {
				frontOf1 = class1values.get(counter1);
				frontOf2 = class2values.get(counter2);

				if (frontOf1 == frontOf2) {
					if (!valuesToKeep.contains(frontOf1))                               { valuesToKeep.add(frontOf1); }
					if (focus == 1) { if (old1 != null && !valuesToKeep.contains(old1)) { valuesToKeep.add(old1); } }
					if (focus == 2) { if (old2 != null && !valuesToKeep.contains(old2)) { valuesToKeep.add(old2); } }
					counter1++;
					counter2++;	
					old1 = frontOf1;
					old2 = frontOf2;
				} else if (focus == 1 && frontOf1 < frontOf2) {
					old1  = frontOf1;
					counter1++;  // Keep advancing.
				} else if (focus == 2 && frontOf2 < frontOf1) {
					old2  = frontOf2;
					counter2++;  // Keep advancing.
				} else if (frontOf1 < frontOf2) {
					if (old2 != null && old2 <= frontOf1) { // Have crossed a 'transition' in the two lists.
						if (!valuesToKeep.contains(old2))     { valuesToKeep.add(old2);     }
						if (!valuesToKeep.contains(frontOf1)) { valuesToKeep.add(frontOf1); }
					}
					counter1++; // List 1 is now the smaller.
					old1  = frontOf1;	
					focus = 1;
				} else { // frontOf1 > frontOf2   NOTE: dont need -inf and + inf for first numbers?
					if (old1 != null && old1 <= frontOf2) { // Have crossed a 'transition' in the two lists.
						if (!valuesToKeep.contains(old1))     { valuesToKeep.add(old1);     }
						if (!valuesToKeep.contains(frontOf2)) { valuesToKeep.add(frontOf2); }
					}
					counter2++; // List 2 is now the smaller.
					old2  = frontOf2;
					focus = 2;
				}				
			}
			// Need to handle any remaining numbers on one list or the other.
			if (counter1 <  numbClass1values) { if (!valuesToKeep.contains(frontOf1)) { valuesToKeep.add(frontOf1); }}
			if (counter2 <  numbClass2values) { if (!valuesToKeep.contains(frontOf2)) { valuesToKeep.add(frontOf2); }}
			if (counter1 >= numbClass1values) { if (!valuesToKeep.contains(old1))     { valuesToKeep.add(old1); }}
			if (counter2 >= numbClass2values) { if (!valuesToKeep.contains(old2))     { valuesToKeep.add(old2); }}
			
			// Do a final sorting rather than having the above lines check for various cases.			
			class1values = valuesToKeep;
			class2values = null;

			if (Utils.getSizeSafely(class1values) > (createTiles ? 550 : 110000)) { // If we have a lot of candidates, define a (potentially) larger than usual tolerance.
				double min = Double.POSITIVE_INFINITY;
				double max = Double.NEGATIVE_INFINITY;
				for (Double dbl : class1values) {
					if (dbl < min) { min = dbl; }
					if (dbl > max) { max = dbl; }
				}
				double thresholdForEquivalence = Math.max(0.000001, (max - min) / 10000);
				double thresholdForNearZero    = Math.max(8 * Double.MIN_NORMAL, thresholdForEquivalence / 10);
				Utils.sortListOfDoublesAndRemoveDuplicates(valuesToKeep, thresholdForEquivalence, thresholdForNearZero); // Sorting is done in place.
			} else {
				Utils.sortListOfDoublesAndRemoveDuplicates(valuesToKeep); // Sorting is done in place.
			}
			
			if (Utils.getSizeSafely(class1values) > (createTiles ? 550 : 110000)) { // Will reduce to 500 (if creating tiles; 500^2 = 250000, but we only use roughly half since we need lower < upper), but don't bother if 'close'.

				List<Double> newClass1values = new ArrayList<>(500);
				double prob = (createTiles ? 500.0 : 100000.0) / Utils.getSizeSafely(class1values);
				for (Double dbl : class1values) if (Utils.random() <= prob) { newClass1values.add(dbl); }
				class1values = newClass1values;
			}
		} 
		
		int remainingThresholds = Utils.getSizeSafely(class1values);
		remainingThresholds    += Utils.getSizeSafely(class2values);		
		if  (remainingThresholds < 1) {
			return;
		}
		
		if (Utils.getSizeSafely(class1values) > 0 && Utils.getSizeSafely(class2values) > 0) {
			Utils.error("Something went wrong.  Have |class1values| = " + Utils.comma(class1values) + " and |class2values| = " + Utils.comma(class2values) + ".");
		}
		else if (Utils.getSizeSafely(class1values) +  Utils.getSizeSafely(class2values) > 1) {	// Need more than one value to make thresholds. 			
			// Create a mode for the new predicate.
	   		List<Term> extendedArguments = new ArrayList<>(literalToThreshold.numberArgs());
	   		extendedArguments.addAll(literalToThreshold.getArguments()); // Need NEW list.
	        
	   		Term     termThresholded = literalToThreshold.getArguments().get(literalToThreshold.positionToThreshold - 1);
	   		TypeSpec spec            = termThresholded.getTypeSpec();
	   		Term     newTypedTerm    = stringHandler.getAnonymousTerm(new TypeSpec("#", spec.isaType.typeName, stringHandler));
	   		extendedArguments.add(newTypedTerm); // The lower bound.
	   		extendedArguments.add(newTypedTerm); // And the upper.
	   		PredicateName newPname    = stringHandler.getPredicateName(literalToThreshold.predicateName + "_WILL_temporaryInBetween");
	   		Literal       extendedLit = stringHandler.getLiteral(newPname, extendedArguments);
            int arity = extendedArguments.size();
	   		if (printStream != null) printStream.println("mode: " + extendedLit + ".");
			stringHandler.recordMode(extendedLit);
			
			RelevanceStrength strength = literalToThreshold.predicateName.getRelevance(literalToThreshold.numberArgs());
			if (strength != null) { 
				stringHandler.setRelevance(extendedLit.predicateName, extendedLit.numberArgs(), strength);
				if (printStream != null) printStream.println("relevance: " + newPname + "/" + extendedLit.numberArgs() + " " + strength);
			}
			
			// ARE THESE DONE AFTER THE RELEVANT SET IS CONSIDERED?
			
			innerLoopForILP.bodyModes.add( new PredicateNameAndArity(newPname, arity));

			newPname.setIsaInterval_1D(extendedArguments.size(), true); stringHandler.needPruner = true;
			if (printStream != null) printStream.println("isaInterval: " + newPname + "/" + extendedArguments.size() + ", 1D, boundariesAtEnd.");
			
	   		// Write BK for the new predicate.
	   		// Sample:		f_inBetween(X, Y, Value, Z, Lower, Upper)
	   		//					:- f(X, Y, Value, Z),
	   		//			   		   isa_f_inBetween(Lower, Upper),
	   		//			           Lower <= Value, Value < Upper.
	   		List<Term> variablizedArguments = new ArrayList<>(literalToThreshold.numberArgs());
	   		Variable   valueVar             = stringHandler.getGeneratedVariable(stringHandler.getVariablePrefix() + "Value" + (++valueCounter) + "_InThesh", true);
	   		for (int i = 1; i <= literalToThreshold.numberArgs(); i++) {
	   			if (i == literalToThreshold.positionToThreshold) { variablizedArguments.add(valueVar); }
	   			else                                             { variablizedArguments.add(stringHandler.getGeneratedVariable(stringHandler.getVariablePrefix() + "Var" + (++varCounter) + "_" + i + "_InThesh", true)); }
	   		}
	   		Variable lower = stringHandler.getGeneratedVariable(stringHandler.getVariablePrefix() + "Lower" + (++lowerCounter) + "_InThesh", true);
	   		Variable upper = stringHandler.getGeneratedVariable(stringHandler.getVariablePrefix() + "Upper" + (++upperCounter) + "_InThesh", true);
	   		List<Term> copyOfVariablizedArguments = new ArrayList<>(variablizedArguments.size());
	   		copyOfVariablizedArguments.addAll(variablizedArguments); // Need to make a COPY so when adding to variablizedArguments, this arguments to 'literalVariablized' are not also changed. 
	   		Literal literalVariablized = stringHandler.getLiteral(literalToThreshold.predicateName, copyOfVariablizedArguments);
	   		variablizedArguments.add(lower);
	   		variablizedArguments.add(upper);
	   		Literal headVariablized = stringHandler.getLiteral(newPname, variablizedArguments);
	   		PredicateName  isaPname = stringHandler.getPredicateName("isa_" + newPname.name);
	   		isaPname.addFilter();
	   		if (printStream != null) printStream.println("filter: " + isaPname + ". // This predicate should be deleted from a learned rule.");
	   		List<Term> args = new ArrayList<>(2);
	   		args.add(lower);
	   		args.add(upper);
	   		Literal isaInBetween    = stringHandler.getLiteral(isaPname, args);
	   		args = new ArrayList<>(2);  // Need fresh copy.
	   		args.add(lower);
	   		args.add(valueVar);
	   		Literal lte             = stringHandler.getLiteral(stringHandler.standardPredicateNames.lte, args);
	   		args = new ArrayList<>(2);  // Need fresh copy.
	   		args.add(valueVar);
	   		args.add(upper);
	   		Literal gt              = stringHandler.getLiteral(stringHandler.standardPredicateNames.lt,  args);
	   		Clause newBKclause      = stringHandler.getClause(headVariablized, true);
	   		newBKclause.negLiterals = new ArrayList<>(4);
	   		newBKclause.negLiterals.add(literalVariablized);
	   		newBKclause.negLiterals.add(isaInBetween);
	   		newBKclause.negLiterals.add(lte);
	   		newBKclause.negLiterals.add(gt);
	   		if (printStream != null) printStream.println(newBKclause.toPrettyString("       ", Integer.MAX_VALUE) + ".");
	   		innerLoopForILP.addRule(newBKclause);
	   		inlineManager.addInventedClause(headVariablized);
	   		if (printStream != null) printStream.println("inline: " + headVariablized.predicateName + "/" + headVariablized.numberArgs() + ".");
	   		
	   		// Next create a NEGATED version of the interval TODO have a flag to override this.
	   		Literal  negatedHead      = headVariablized.copy(false);
	   		negatedHead.predicateName = stringHandler.getPredicateName("not_" + headVariablized.predicateName.name);
			PredicateName nbf      = stringHandler.standardPredicateNames.negationByFailure; // Negation by failure.
			List<Term>    nbf_args = new ArrayList<>(1);
			nbf_args.add(headVariablized.convertToFunction(stringHandler));
	   		Literal  negationByFailureOfHead = stringHandler.getLiteral(nbf, nbf_args);
	   		Clause   newNegatedBKclause      = stringHandler.getClause(negatedHead, true);
	   		newNegatedBKclause.negLiterals = new ArrayList<>(1);
	   		newNegatedBKclause.negLiterals.add(negationByFailureOfHead);
	   		if (printStream != null) printStream.println(newNegatedBKclause.toPrettyString("       ", Integer.MAX_VALUE) + ". // Negation-by-failure version.");
	   		innerLoopForILP.addRule(newNegatedBKclause);
	   		inlineManager.addInventedClause(negatedHead);
	   		if (printStream != null) printStream.println("inline: " + negatedHead.predicateName + "/" + negatedHead.numberArgs() + ".");	   
	   		if (printStream != null) printStream.println("mode: not_" + extendedLit + ".");		
	   		
	   		// Add to the facts, the boundaries associated with this new predicate.
	   		// Eg:
   			//     isa_f_inBetween(Double.NEGATIVE_INFINITY, split).
   			//     isa_f_inBetween(split, Double.POSITIVE_INFINITY).
	   		NumericConstant negInf      = stringHandler.getNumericConstant(Double.NEGATIVE_INFINITY);
	   		NumericConstant posInf      = stringHandler.getNumericConstant(Double.POSITIVE_INFINITY);
	   		int numbValues = class1values.size();
			List<Sentence> betweens = new ArrayList<>(4);  // Using Sentence here so addFacts() can be called at end.
	   		if (createTiles) {
	   			for (int i = 1; i <= numbValues; i++) { // Skip the first one, since no reason to have this be the upper bound, since no numbers less than it (recall that upper bounds are NOT in intervals).
	   				for (int j = -1; j < i - 1; j++) if (j >= 0 || i < numbValues) { // Don't generate the case [-inf, +inf].
	   			   		double          splitL0       = (j <  0          ? Double.NEGATIVE_INFINITY : class1values.get(j));
	   			   		double          splitL1       =                                               class1values.get(j + 1);
	   			   		double          splitU0       =                                               class1values.get(i - 1);
	   			   		double          splitU1       = (i == numbValues ? Double.POSITIVE_INFINITY : class1values.get(i));
	   			   		double          splitL        = (splitL0 + splitL1) / 2;
	   			   		double          splitU        = (splitU0 + splitU1) / 2;
	   			   		NumericConstant splitL_asTerm = (j <  0          ? negInf : stringHandler.getNumericConstant(splitL));
	   			   		NumericConstant splitU_asTerm = (i == numbValues ? posInf : stringHandler.getNumericConstant(splitU));
	   			   	
	   			   		args = new ArrayList<>(2); // Need a fresh copy.
	   			   		args.add(splitL_asTerm);
	   			   		args.add(splitU_asTerm);
	   			   		Literal isaBetween = stringHandler.getLiteral(isaPname, args);
	   			   		betweens.add(isaBetween);
	   					
	   				}
	   			}	   			
	   		} else for (int i = 1; i < numbValues; i++) {
		   		double          split       =  (class1values.get(i - 1) + class1values.get(i)) / 2;
		   		NumericConstant splitAsTerm = stringHandler.getNumericConstant(split);
		   		
		   		args = new ArrayList<>(2); // Need a fresh copy.
			   	args.add(negInf);
			   	args.add(splitAsTerm);
		   		Literal isaBetween1 = stringHandler.getLiteral(isaPname, args);
		   		args = new ArrayList<>(2); // Need a fresh copy.
			   	args.add(splitAsTerm);
			   	args.add(posInf);
		   		Literal isaBetween2 = stringHandler.getLiteral(isaPname, args);
		   		betweens.add(isaBetween1);	
		   		betweens.add(isaBetween2);
		   	}

			if (maxCuts > 0 && Utils.getSizeSafely(betweens) > maxCuts) {
				// TODO write better code for this, e.g. discard points closest to each other or use information gain.

				// If a large number of possible cuts, reduce to 100x the number we want before computing info gain.
				if (Utils.getSizeSafely(betweens) > 100 * maxCuts) { Utils.reduceToThisSizeByRandomlyDiscardingItemsInPlace(betweens, 100 * maxCuts); }
				List<ScoredSentence> scores = new ArrayList<>(betweens.size());
				for (Sentence tweener : betweens) {
					Literal lit = (Literal) tweener;  // These will look like: 'isa_f_WILLinBetween(1.0, 3.0)'   Utils.println("lit = " + lit);
					double lowerLit = ((NumericConstant) lit.getArgument(0)).value.doubleValue();
					double upperLit = ((NumericConstant) lit.getArgument(1)).value.doubleValue();
					int    numberClass1Covered    = 0;
					int    numberClass2Covered    = 0;
					int    numberClass1NotCovered = 0;
					int    numberClass2NotCovered = 0;

					for (Double value : orgList1) {
						if (value >= lowerLit && value < upperLit) { numberClass1Covered++;    }
						else                                       { numberClass1NotCovered++; }
					}
					for (Double value : orgList2) {
						if (value >= lowerLit && value < upperLit) { numberClass2Covered++;    }
						else                                       { numberClass2NotCovered++; }
					}

					int    covered     = numberClass1Covered    + numberClass2Covered;
					int    notCovered  = numberClass1NotCovered + numberClass2NotCovered;
					double total       = covered + notCovered;
					double fractTrue   = (total < 1 ? 0 : covered    / total);
					double fractFalse  = (total < 1 ? 0 : notCovered / total);
					double fract1true  = (covered    < 1 ? 0 : numberClass1Covered    / (double)covered);    // Of those true,  what fraction are of class 1?
					double fract1false = (notCovered < 1 ? 0 : numberClass1NotCovered / (double)notCovered); // Of those false, what fraction are of class 2?
					double infoLeft    = fractTrue * calcInfo(fract1true) + fractFalse * calcInfo(fract1false);

					scores.add(new ScoredSentence(tweener, infoLeft));

					// If a perfect split exists, keep it?  Maybe not, if tuning sets are being used ...

					// Fill half the quota using infoLeft and the other half randomly (since info needs to be conditioned on rest of clause).
				}
				scores.sort(new ScoredSentenceComparator());
				List<Sentence> newBetweens = new ArrayList<>(maxCuts);
				int counter = maxCuts / 2;  // Fill half with the BEST and the rest choose randomly (in case all the best cuts are near each other). TODO could use some clustering algorithm.
				for (ScoredSentence s : scores) {
					newBetweens.add(s.sentence);
					betweens.remove(s.sentence);
					if (--counter <= 0) { break; }
				}
				// Randomly discard some of the remaining 'betweens.'
				Utils.reduceToThisSizeByRandomlyDiscardingItemsInPlace(betweens, maxCuts - Utils.getSizeSafely(newBetweens));
				newBetweens.addAll(betweens);
				betweens = newBetweens;

			}

			innerLoopForILP.addFacts(betweens);
			int betweenCounter = 0;
			for (Sentence between : betweens) {
				betweenCounter++;
				Utils.println(MessageType.ILP_THESHOLDING_VERBOSE,                          "%  " + between + ". % #" + Utils.comma(betweenCounter));
				if (printStream != null) printStream.println(  between + ". % #" + Utils.comma(betweenCounter));
			}
		}
	}
	
	private double calcInfo(double fractionClass1) {
		double lg      = (   fractionClass1 > 1000 * Double.MIN_VALUE ? Math.log(    fractionClass1) / Math.log(2) : 0);
		double lgMinus = (1- fractionClass1 > 1000 * Double.MIN_VALUE ? Math.log(1 - fractionClass1) / Math.log(2) : 0);
		
		return -fractionClass1 * lg - (1 - fractionClass1) * lgMinus;
	}
}
class ScoredSentence {
	final Sentence sentence;
	final double   score;
	
	ScoredSentence(Sentence sentence, double score) {
		super();
		this.sentence = sentence;
		this.score    = score;
	}	
	
	public String toString() {
		return sentence + "[" + score + "]";
	}
}
class ScoredSentenceComparator implements Comparator<ScoredSentence> {

	public int compare(ScoredSentence one, ScoredSentence two) {
		double sOne = one.score;
		double sTwo = two.score;

		return Double.compare(sOne, sTwo);
	}
}
